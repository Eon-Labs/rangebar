# Rangebar Master Implementation Plan
project: rangebar
version: 4.0.0
objective: Complete rangebar system with Arrow/Parquet integration and comprehensive market type support

plan_type: master_implementation_plan
consolidates: 
  - implementation-plan.yml
  - arrow-parquet-integration.yml  
  - success-gates.yml
  - progress.yml
last_consolidated: "2025-09-10T19:04:00Z"

overview: |
  Integrate Apache Arrow columnar format and Parquet files to provide zero-copy
  memory mapping and seamless Python time series integration. Full support for
  SPOT, UM Perpetual Futures, and CM Perpetual Futures with clear data lineage.

current_state:
  rust_implementation: ✅ Pure Rust range bar construction working
  primary_data_source: data.binance.vision UM Futures aggTrades
  supported_markets: [um_futures]  # Currently UM only
  export_formats: [CSV, JSON]
  algorithm: Non-lookahead bias, ±0.8% threshold from bar open
  performance: ~2M trades in 15-20 seconds

# CRITICAL: Market Type Specifications
market_type_specifications:
  um_futures:
    description: "USDⓈ-Margined Perpetual Futures"
    data_source: "data.binance.vision/data/futures/um/daily/aggTrades/"
    symbol_format: "BTCUSDT" 
    settlement: "USDT"
    margin_type: "cross/isolated"
    identifier: "um"
    current_support: ✅
    
  cm_futures:
    description: "Coin-Margined Perpetual Futures" 
    data_source: "data.binance.vision/data/futures/cm/daily/aggTrades/"
    symbol_format: "BTCUSD_PERP"
    settlement: "BTC/ETH/etc"
    margin_type: "cross/isolated" 
    identifier: "cm"
    current_support: ❌ (planned)
    
  spot:
    description: "Spot Trading Pairs"
    data_source: "data.binance.vision/data/spot/daily/aggTrades/"
    symbol_format: "BTCUSDT"
    settlement: "immediate"
    margin_type: "none"
    identifier: "spot"
    current_support: ❌ (planned)

# Enhanced File Naming Conventions with Market Type
file_naming_conventions:
  arrow:
    pattern: "{market_type}_{symbol}_rangebar_{start_date}_{end_date}_{threshold:.3}pct_v{schema_version}.arrow"
    examples:
      - "um_BTCUSDT_rangebar_20250801_20250801_0.800pct_v1.arrow"
      - "cm_BTCUSD_PERP_rangebar_20250801_20250801_0.800pct_v1.arrow" 
      - "spot_BTCUSDT_rangebar_20250801_20250801_0.800pct_v1.arrow"
  
  parquet:
    pattern: "{market_type}_{symbol}_rangebar_{start_date}_{end_date}_{threshold:.3}pct_v{schema_version}_{compression}.parquet"
    examples:
      - "um_BTCUSDT_rangebar_20250801_20250801_0.800pct_v1_snappy.parquet"
      - "cm_BTCUSD_PERP_rangebar_20250801_20250801_0.800pct_v1_snappy.parquet"
      - "spot_BTCUSDT_rangebar_20250801_20250801_0.800pct_v1_snappy.parquet"
      
  csv_json:
    pattern: "{market_type}_{symbol}_rangebar_{start_date}_{end_date}_{threshold:.3}pct.{csv|json}"
    examples:
      - "um_BTCUSDT_rangebar_20250801_20250801_0.800pct.csv"
      - "cm_BTCUSD_PERP_rangebar_20250801_20250801_0.800pct.json"
      - "spot_ETHUSDT_rangebar_20250801_20250801_0.800pct.csv"
    note: "Enhanced naming with market type prefix for clear data lineage"

# Directory Organization Strategies
directory_organization:
  strategy_1_market_segregated:
    description: "Separate by market type first, then by format"
    structure: |
      output/
      ├── um_futures/
      │   ├── arrow/
      │   ├── parquet/
      │   └── csv_json/
      ├── cm_futures/
      │   ├── arrow/
      │   ├── parquet/
      │   └── csv_json/
      └── spot/
          ├── arrow/
          ├── parquet/
          └── csv_json/
    pros: ["Clear market separation", "Easy market-specific tooling"]
    cons: ["Deeper directory nesting"]
    
  strategy_2_format_segregated:
    description: "Separate by format first, with market type in filenames"
    structure: |
      output/
      ├── arrow/
      ├── parquet/
      └── csv_json/
    pros: ["Format-focused organization", "Consistent with current structure"]
    cons: ["Market types mixed in same directory"]
    
  strategy_3_hive_partitioned:
    description: "Hive-style partitioning for large datasets"
    structure: |
      output/
      ├── market_type=um_futures/
      │   └── symbol=BTCUSDT/
      │       └── year=2025/
      │           └── month=08/
      ├── market_type=cm_futures/
      └── market_type=spot/
    pros: ["Optimal for big data tools", "Natural filtering"]
    cons: ["Complex for simple use cases"]

# Arrow Schema Definition with Market Type Metadata
arrow_schema:
  fields:
    - name: "bar_id"
      type: "uint64"
      nullable: false
      
    - name: "open_time"
      type: "timestamp[ms]" 
      nullable: false
      
    - name: "close_time"
      type: "timestamp[ms]"
      nullable: false
      
    - name: "open"
      type: "decimal128(18, 8)"  # 8 decimal precision
      nullable: false
      
    - name: "high"
      type: "decimal128(18, 8)"
      nullable: false
      
    - name: "low"
      type: "decimal128(18, 8)"
      nullable: false
      
    - name: "close"
      type: "decimal128(18, 8)"
      nullable: false
      
    - name: "volume"
      type: "decimal128(18, 8)"
      nullable: false
      
    - name: "trade_count"
      type: "uint32"
      nullable: false
      
  # CRITICAL: Metadata for data lineage
  metadata:
    - key: "market_type"
      description: "Market type identifier (um_futures, cm_futures, spot)"
      
    - key: "data_source"
      description: "Original data source URL"
      
    - key: "symbol"
      description: "Trading symbol"
      
    - key: "threshold_bps"
      description: "Range threshold in basis points"
      
    - key: "algorithm_version"
      description: "Range bar algorithm version"
      
    - key: "schema_version"
      description: "Schema version for compatibility"
      
    - key: "created_at"
      description: "File creation timestamp"
      
    - key: "rust_version"
      description: "Rust compiler version used"

# Dataset Catalog and Discovery
dataset_catalog:
  catalog_file: "rangebar_catalog.json"
  format: |
    {
      "version": "1.0.0",
      "datasets": [
        {
          "id": "um_btcusdt_20250801_0800bps",
          "market_type": "um_futures",
          "symbol": "BTCUSDT", 
          "date_range": ["2025-08-01", "2025-08-01"],
          "threshold_pct": 0.008,
          "bar_count": 11,
          "trade_count": 1898706,
          "formats": {
            "arrow": "um_BTCUSDT_rangebar_20250801_20250801_0.800pct_v1.arrow",
            "parquet": "um_BTCUSDT_rangebar_20250801_20250801_0.800pct_v1_snappy.parquet",
            "csv": "um_BTCUSDT_rangebar_20250801_20250801_0.800pct.csv",
            "json": "um_BTCUSDT_rangebar_20250801_20250801_0.800pct.json"
          },
          "metadata": {
            "data_source": "data.binance.vision/data/futures/um/daily/aggTrades/",
            "created_at": "2025-09-10T17:45:00Z",
            "algorithm_version": "1.0.0",
            "rust_version": "1.70.0"
          }
        }
      ]
    }

# Python Discovery Helper Functions
python_integration:
  discovery_functions: |
    # Auto-generated Python helper for dataset discovery
    
    import json
    import pandas as pd
    import polars as pl
    from pathlib import Path
    from typing import List, Dict, Optional
    
    class RangeBarDatasetCatalog:
        def __init__(self, catalog_path: str = "rangebar_catalog.json"):
            with open(catalog_path) as f:
                self.catalog = json.load(f)
        
        def list_datasets(self, 
                         market_type: Optional[str] = None,
                         symbol: Optional[str] = None) -> List[Dict]:
            """List available datasets with optional filtering."""
            datasets = self.catalog["datasets"]
            
            if market_type:
                datasets = [d for d in datasets if d["market_type"] == market_type]
            if symbol:
                datasets = [d for d in datasets if d["symbol"] == symbol]
                
            return datasets
        
        def load_arrow(self, dataset_id: str) -> pd.DataFrame:
            """Load dataset as pandas DataFrame from Arrow format."""
            dataset = self._get_dataset(dataset_id)
            arrow_file = dataset["formats"]["arrow"]
            return pd.read_feather(arrow_file)
        
        def load_parquet(self, dataset_id: str) -> pd.DataFrame:
            """Load dataset as pandas DataFrame from Parquet format."""
            dataset = self._get_dataset(dataset_id)
            parquet_file = dataset["formats"]["parquet"]  
            return pd.read_parquet(parquet_file)
        
        def load_polars(self, dataset_id: str) -> pl.LazyFrame:
            """Load dataset as Polars LazyFrame (zero-copy)."""
            dataset = self._get_dataset(dataset_id)
            parquet_file = dataset["formats"]["parquet"]
            return pl.scan_parquet(parquet_file)
        
        def get_market_types(self) -> List[str]:
            """Get all available market types."""
            return list(set(d["market_type"] for d in self.catalog["datasets"]))
        
        def get_symbols(self, market_type: Optional[str] = None) -> List[str]:
            """Get all available symbols, optionally filtered by market type."""
            datasets = self.list_datasets(market_type=market_type)
            return list(set(d["symbol"] for d in datasets))

# Implementation Phases - EMPIRICAL WORKFLOW
implementation_phases:
  phase_1_algorithm_validation:
    description: "Algorithm correctness and performance validation" 
    status: ✅ Complete
    empirical_insight: "Must validate algorithm before expanding formats"
    tasks:
      - ✅ "Implement breach consistency validation"
      - ✅ "Performance benchmarking (target: 1M ticks < 100ms)"
      - ✅ "Real data processing validation"
      - ✅ "Step-by-step verification methodology"
    success_criteria:
      - ✅ "Algorithm correctness verified via breach consistency"
      - ✅ "Performance targets exceeded (116M trades/sec)"
      - ✅ "Real Binance data processing validated (1.38M trades)"
      
  phase_2_foundation_security:
    description: "Security updates and dependency management"
    status: ✅ Complete  
    empirical_insight: "Security foundation required before production features"
    tasks:
      - ✅ "Fix dependency vulnerabilities (pyo3, polars)"
      - ✅ "Remove unused dependencies"
      - ✅ "Setup pre-commit hooks and quality gates"
      - ✅ "Implement automated testing framework"
    success_criteria:
      - ✅ "All security vulnerabilities resolved"
      - ✅ "Clean dependency tree"
      - ✅ "Automated quality assurance"
      
  phase_3_arrow_parquet_integration:
    description: "Modern binary format support"
    status: ❌ Not Started
    priority: "HIGH - Core missing functionality"
    tasks:
      - "Add arrow and parquet crate dependencies to Cargo.toml"
      - "Implement Arrow schema with decimal128 precision"
      - "Add Parquet writer with Snappy compression"
      - "Implement metadata preservation in binary formats"
    success_criteria:
      - "Generate .arrow and .parquet files"
      - "Pandas can load with read_feather() and read_parquet()"
      - "20-80% file size reduction vs CSV/JSON"
      - "Zero-copy memory mapping works"
      
  phase_4_multi_market_expansion:
    description: "CM futures and SPOT market support"
    status: ❌ Not Started
    dependency: "Requires Phase 3 for market_type parameter"
    tasks:
      - "Add market_type parameter to CLI (um_futures, cm_futures, spot)"
      - "Implement CM futures data fetching"
      - "Add SPOT market support"
      - "Update file naming with market type prefix"
    success_criteria:
      - "All three market types supported"
      - "Clear data lineage in metadata"
      - "Market-specific symbol handling (BTCUSD_PERP vs BTCUSDT)"
      
  phase_5_comprehensive_format_validation:
    description: "Cross-format coherence testing framework"
    status: ❌ Partial (basic validation only)
    dependency: "Requires Phase 3 (multiple formats) + Phase 4 (multiple markets)"
    empirical_insight: "Comprehensive testing needed after format expansion"
    tasks:
      - "Implement automated validation suite (master-format-validation.sh)"
      - "Cross-format coherence testing (CSV, JSON, Arrow, Parquet)"
      - "Regression testing matrix across markets and thresholds"
      - "Performance validation across all formats"
    success_criteria:
      - "All formats produce identical data"
      - "Automated validation passes for all market types"
      - "Regression testing matrix operational"
      
  phase_6_python_ecosystem_integration:
    description: "Python discovery tools and ecosystem integration"
    status: ❌ Not Started
    dependency: "Requires Phase 3-5 complete"
    tasks:
      - "Generate dataset catalog (rangebar_catalog.json)"
      - "Implement Python discovery helper (RangeBarDatasetCatalog)"
      - "Add Jupyter notebook examples"
      - "Create conda/pip package distribution"
    success_criteria:
      - "Seamless Python integration"
      - "Easy dataset discovery via catalog"
      - "Zero-copy polars LazyFrame loading"

# CLI Interface Enhancements
cli_enhancements:
  new_parameters:
    market_type:
      description: "Market type identifier"
      type: "enum[um_futures, cm_futures, spot]"
      default: "um_futures"
      examples: ["--market-type um_futures"]
      
    output_format:
      description: "Output format selection"
      type: "enum[csv, json, arrow, parquet, all]"
      default: "parquet"  # Parquet preferred for modern workflows
      examples: ["--format arrow,parquet", "--format csv,json"]
      
    compression:
      description: "Parquet compression algorithm"
      type: "enum[snappy, gzip, lz4, zstd]"
      default: "snappy"
      examples: ["--compression snappy"]

# Default Format Strategy & Rationale
default_format_strategy:
  rationale: |
    After careful consideration, Parquet is chosen as the default format for modern
    workflows while maintaining full backward compatibility with CSV/JSON.

  parquet_advantages:
    performance:
      - "20-80% smaller file sizes vs JSON/CSV"
      - "Zero-copy memory mapping in Python"
      - "Columnar storage optimized for time series analysis"
      - "Built-in compression (Snappy default)"
    
    ecosystem_support:
      - "Native pandas.read_parquet() support"  
      - "Polars LazyFrame zero-copy loading"
      - "Apache Spark integration"
      - "DuckDB direct querying"
    
    metadata_preservation:
      - "Market type stored in file metadata"
      - "Data source lineage preserved"
      - "Schema versioning for evolution"
      - "Timestamp precision maintained"

  migration_strategy:
    new_users: "Default to Parquet for best experience"
    existing_users: "Explicit --format csv,json maintains compatibility"
    automation: "Scripts can specify preferred format explicitly"
    
  format_recommendations:
    data_analysis: "parquet (recommended) - Best for pandas/polars workflows"
    human_readable: "csv,json - For manual inspection and simple tools" 
    archival: "parquet - Compact storage with metadata preservation"
    streaming: "arrow - Future streaming support (planned)"
    compatibility: "csv,json - Maximum tool compatibility"

  backward_compatibility_guarantee:
    commitment: |
      Existing users can always generate CSV/JSON output using:
      - `--format csv,json` (explicit)
      - Environment variable: `RANGEBAR_DEFAULT_FORMAT=csv,json`
      - Configuration file support (planned)
    
    migration_timeline:
      v3.0: "Parquet default, CSV/JSON fully supported"
      v3.1: "Add environment variable and config file support"
      v4.0: "CSV/JSON remain supported, no deprecation planned"

# Backward Compatibility Strategy  
backward_compatibility:
  file_naming:
    current: "BTCUSDT_rangebar_20250801_20250801_0.800pct.csv"
    enhanced: "um_BTCUSDT_rangebar_20250801_20250801_0.800pct.csv"
    strategy: "Add market type prefix, maintain rest of pattern"
    
  cli_interface:
    strategy: "Default to um_futures for backward compatibility"
    migration_path: "Gradual adoption of --market-type parameter"
    
  existing_files:
    strategy: "Leave existing files unchanged, new files use enhanced naming"
    cleanup: "Optional migration script to rename existing files"

# Quality Assurance
quality_assurance:
  data_integrity:
    - "Verify Arrow/Parquet data matches CSV output"
    - "Schema validation on write and read"
    - "Metadata consistency checks"
    
  performance_targets:
    arrow_write: "< 5% overhead vs CSV"
    parquet_write: "< 15% overhead vs CSV"
    python_load: "> 10x faster than CSV"
    
  compatibility_matrix:
    pandas: ">= 1.3.0"
    polars: ">= 0.15.0"  
    arrow: ">= 10.0.0"
    python: ">= 3.8"

# Development & Debugging Rationale - CSV/JSON PRIORITY
development_methodology:
  debugging_philosophy: |
    CRITICAL: Implementation phases must prioritize CSV/JSON formats first for debugging efficiency.
    CSV is plain text format allowing easy inspection with READ/CAT tools via Claude Code CLI,
    enabling rapid validation and troubleshooting before implementing binary formats (Arrow/Parquet).
  
  priority_order:
    phase_1_csv_json_foundation:
      description: "Implement CSV/JSON first for debugging ease"
      rationale: "Plain text allows eyeball inspection with READ tool"
      validation_strategy: "head/tail/wc commands for quick inspection"
      debugging_efficiency: "Immediate visibility into data structure and values"
      
    phase_2_arrow_integration:
      description: "Add Arrow format with CSV/JSON as reference baseline"
      validation_strategy: "Cross-validate Arrow output against CSV baseline"
      
    phase_3_parquet_optimization:
      description: "Add Parquet with compression and metadata"
      validation_strategy: "Triple validation: CSV baseline, Arrow coherence, Parquet optimization"

  claude_code_cli_debugging_advantages:
    csv_inspection:
      - "head -10 output.csv → Immediate header and data visibility"
      - "tail -5 output.csv → Check final bars for truncation issues"
      - "wc -l output.csv → Instant bar count validation"
      - "awk inspection for specific fields without loading full file"
      
    json_inspection:
      - "head -1 output.json | python -m json.tool → Structure validation"
      - "python one-liners for quick statistics and field checking"
      - "Human-readable format for manual verification"
      
    binary_format_limitations:
      - "Arrow/Parquet require specialized tools for inspection"
      - "Cannot use simple Unix tools for quick debugging"
      - "Need Python/pandas loaded for any meaningful inspection"

# Format Validation & Coherence Testing
format_validation_methodology:
  overview: |
    Comprehensive iterative testing framework to ensure all three format types 
    (CSV/JSON, Arrow, Parquet) produce coherent and identical data when processed
    from the same source. Uses Claude Code CLI for debugging and validation.
  
  three_format_groups:
    group_1_legacy:
      formats: ["CSV", "JSON"]
      description: "Human-readable formats for compatibility and inspection"
      validation_priority: "baseline_reference"
      
    group_2_columnar: 
      formats: ["Arrow"]
      description: "Columnar memory-mapped format for zero-copy operations"
      validation_priority: "performance_optimized"
      
    group_3_compressed:
      formats: ["Parquet"]  
      description: "Compressed columnar format with metadata preservation"
      validation_priority: "production_default"

  iterative_testing_methodology:
    step_1_generate_all_formats:
      command: |
        # Generate all formats from same dataset for comparison
        cargo run --release --bin rangebar_export -- BTCUSDT 2025-08-01 2025-08-01 0.008 ./validation_output --format all
      expected_outputs:
        - "um_BTCUSDT_rangebar_20250801_20250801_0.800pct.csv"
        - "um_BTCUSDT_rangebar_20250801_20250801_0.800pct.json"
        - "um_BTCUSDT_rangebar_20250801_20250801_0.800pct_v1.arrow"
        - "um_BTCUSDT_rangebar_20250801_20250801_0.800pct_v1_snappy.parquet"
      
    step_2_verify_file_existence:
      claude_code_cli: |
        # Use Claude Code CLI to verify all expected files exist
        ls ./validation_output/um_BTCUSDT_rangebar_20250801_20250801_0.800pct.*
        
        # Check file sizes are reasonable
        ls -lh ./validation_output/um_BTCUSDT_rangebar_20250801_20250801_0.800pct.*
      
    step_3_load_and_compare_csv_json:
      claude_code_cli: |
        # CSV inspection using Claude Code CLI
        head -5 ./validation_output/um_BTCUSDT_rangebar_20250801_20250801_0.800pct.csv
        tail -5 ./validation_output/um_BTCUSDT_rangebar_20250801_20250801_0.800pct.csv
        wc -l ./validation_output/um_BTCUSDT_rangebar_20250801_20250801_0.800pct.csv
        
        # JSON structure inspection
        head -1 ./validation_output/um_BTCUSDT_rangebar_20250801_20250801_0.800pct.json | python -m json.tool
        python -c "import json; data=json.load(open('./validation_output/um_BTCUSDT_rangebar_20250801_20250801_0.800pct.json')); print(f'Bars: {len(data)}, Fields: {list(data[0].keys()) if data else None}')"
      validation_script: |
        #!/usr/bin/env python3
        """CSV/JSON coherence validation script"""
        import csv
        import json
        from decimal import Decimal
        
        def validate_csv_json_coherence(csv_file, json_file):
            # Load CSV data
            with open(csv_file, 'r') as f:
                csv_reader = csv.DictReader(f)
                csv_data = list(csv_reader)
            
            # Load JSON data  
            with open(json_file, 'r') as f:
                json_data = json.load(f)
            
            # Validate row count matches
            assert len(csv_data) == len(json_data), f"Row count mismatch: CSV={len(csv_data)}, JSON={len(json_data)}"
            
            # Validate field coherence
            for i, (csv_row, json_row) in enumerate(zip(csv_data, json_data)):
                for field in ['bar_id', 'open_time', 'close_time', 'open', 'high', 'low', 'close', 'volume']:
                    csv_val = Decimal(csv_row[field])
                    json_val = Decimal(str(json_row[field]))
                    assert csv_val == json_val, f"Row {i}, field {field}: CSV={csv_val}, JSON={json_val}"
            
            print(f"✅ CSV/JSON coherence validated: {len(csv_data)} bars match perfectly")
            return True
    
    step_4_arrow_format_validation:
      claude_code_cli: |
        # Arrow file inspection using Claude Code CLI
        python -c "
        import pandas as pd
        df = pd.read_feather('./validation_output/um_BTCUSDT_rangebar_20250801_20250801_0.800pct_v1.arrow')
        print(f'Arrow shape: {df.shape}')
        print(f'Columns: {list(df.columns)}')
        print(f'Dtypes: {df.dtypes.to_dict()}')
        print(f'First bar: {df.iloc[0].to_dict()}')
        print(f'Last bar: {df.iloc[-1].to_dict()}')
        "
      validation_script: |
        #!/usr/bin/env python3
        """Arrow format validation script"""
        import pandas as pd
        import json
        from decimal import Decimal
        
        def validate_arrow_coherence(arrow_file, csv_file):
            # Load Arrow as DataFrame
            arrow_df = pd.read_feather(arrow_file)
            
            # Load CSV for comparison
            csv_df = pd.read_csv(csv_file)
            
            # Validate shape matches
            assert arrow_df.shape == csv_df.shape, f"Shape mismatch: Arrow={arrow_df.shape}, CSV={csv_df.shape}"
            
            # Validate numerical precision (Arrow uses decimal128)
            for col in ['open', 'high', 'low', 'close', 'volume']:
                for i in range(len(arrow_df)):
                    arrow_val = Decimal(str(arrow_df.iloc[i][col]))
                    csv_val = Decimal(str(csv_df.iloc[i][col]))
                    assert arrow_val == csv_val, f"Row {i}, {col}: Arrow={arrow_val}, CSV={csv_val}"
            
            print(f"✅ Arrow coherence validated: {len(arrow_df)} bars match CSV precisely")
            return True
    
    step_5_parquet_format_validation:
      claude_code_cli: |
        # Parquet file inspection using Claude Code CLI  
        python -c "
        import pandas as pd
        df = pd.read_parquet('./validation_output/um_BTCUSDT_rangebar_20250801_20250801_0.800pct_v1_snappy.parquet')
        print(f'Parquet shape: {df.shape}')
        print(f'Columns: {list(df.columns)}')
        print(f'Memory usage: {df.memory_usage(deep=True).sum() / 1024**2:.2f} MB')
        print(f'First bar: {df.iloc[0].to_dict()}')
        print(f'Last bar: {df.iloc[-1].to_dict()}')
        
        # Check metadata preservation
        import pyarrow.parquet as pq
        parquet_file = pq.ParquetFile('./validation_output/um_BTCUSDT_rangebar_20250801_20250801_0.800pct_v1_snappy.parquet')
        metadata = parquet_file.metadata_path or 'No metadata'
        print(f'Metadata: {metadata}')
        "
      validation_script: |
        #!/usr/bin/env python3
        """Parquet format validation script"""
        import pandas as pd
        import pyarrow.parquet as pq
        from decimal import Decimal
        import os
        
        def validate_parquet_coherence(parquet_file, csv_file):
            # Load Parquet as DataFrame
            parquet_df = pd.read_parquet(parquet_file)
            
            # Load CSV for comparison
            csv_df = pd.read_csv(csv_file)
            
            # Validate shape matches
            assert parquet_df.shape == csv_df.shape, f"Shape mismatch: Parquet={parquet_df.shape}, CSV={csv_df.shape}"
            
            # Check compression effectiveness
            csv_size = os.path.getsize(csv_file)
            parquet_size = os.path.getsize(parquet_file)
            compression_ratio = (csv_size - parquet_size) / csv_size * 100
            
            print(f"Compression: CSV={csv_size/1024:.1f}KB → Parquet={parquet_size/1024:.1f}KB ({compression_ratio:.1f}% reduction)")
            
            # Validate numerical precision  
            for col in ['open', 'high', 'low', 'close', 'volume']:
                for i in range(len(parquet_df)):
                    parquet_val = Decimal(str(parquet_df.iloc[i][col]))
                    csv_val = Decimal(str(csv_df.iloc[i][col]))
                    assert parquet_val == csv_val, f"Row {i}, {col}: Parquet={parquet_val}, CSV={csv_val}"
            
            print(f"✅ Parquet coherence validated: {len(parquet_df)} bars match CSV precisely")
            return True
    
    step_6_cross_format_coherence_test:
      description: "Ultimate validation: All formats produce identical data"
      claude_code_cli: |
        # Master validation script using Claude Code CLI
        python -c "
        import pandas as pd
        import json
        
        # Load all formats
        csv_df = pd.read_csv('./validation_output/um_BTCUSDT_rangebar_20250801_20250801_0.800pct.csv')
        
        with open('./validation_output/um_BTCUSDT_rangebar_20250801_20250801_0.800pct.json') as f:
            json_data = json.load(f)
        json_df = pd.DataFrame(json_data)
        
        arrow_df = pd.read_feather('./validation_output/um_BTCUSDT_rangebar_20250801_20250801_0.800pct_v1.arrow')
        parquet_df = pd.read_parquet('./validation_output/um_BTCUSDT_rangebar_20250801_20250801_0.800pct_v1_snappy.parquet')
        
        # Assert all shapes match
        assert csv_df.shape == json_df.shape == arrow_df.shape == parquet_df.shape
        
        print(f'✅ All formats have identical shape: {csv_df.shape}')
        print(f'✅ All {len(csv_df)} range bars validated across 4 formats')
        "

  automated_validation_suite:
    master_validation_script: |
      #!/bin/bash
      # master-format-validation.sh
      # Self-explanatory validation suite for Claude Code CLI debugging
      
      set -e
      
      SYMBOL="BTCUSDT"
      DATE="2025-08-01"
      THRESHOLD="0.008"
      OUTPUT_DIR="./validation_output"
      
      echo "🔍 Range Bar Format Validation Suite"
      echo "===================================="
      echo "Symbol: $SYMBOL"
      echo "Date: $DATE"  
      echo "Threshold: $THRESHOLD"
      echo "Output: $OUTPUT_DIR"
      echo ""
      
      # Step 1: Generate all formats
      echo "📊 Step 1: Generating all formats..."
      mkdir -p $OUTPUT_DIR
      cargo run --release --bin rangebar_export -- $SYMBOL $DATE $DATE $THRESHOLD $OUTPUT_DIR --format all
      
      # Step 2: Verify file existence
      echo "📁 Step 2: Verifying file existence..."
      ls -lh $OUTPUT_DIR/um_${SYMBOL}_rangebar_${DATE//-/}_${DATE//-/}_*
      
      # Step 3: CSV/JSON coherence
      echo "🔍 Step 3: CSV/JSON coherence test..."
      python3 -c "
      import csv, json, sys
      from decimal import Decimal
      
      csv_file = '$OUTPUT_DIR/um_${SYMBOL}_rangebar_${DATE//-/}_${DATE//-/}_0.800pct.csv'
      json_file = '$OUTPUT_DIR/um_${SYMBOL}_rangebar_${DATE//-/}_${DATE//-/}_0.800pct.json'
      
      with open(csv_file) as f:
          csv_data = list(csv.DictReader(f))
      with open(json_file) as f:
          json_data = json.load(f)
      
      assert len(csv_data) == len(json_data), f'Count mismatch: {len(csv_data)} vs {len(json_data)}'
      
      for i, (c, j) in enumerate(zip(csv_data, json_data)):
          for field in ['open', 'high', 'low', 'close', 'volume']:
              if Decimal(c[field]) != Decimal(str(j[field])):
                  print(f'❌ Mismatch row {i}, {field}: {c[field]} vs {j[field]}')
                  sys.exit(1)
      
      print(f'✅ CSV/JSON coherent: {len(csv_data)} bars validated')
      "
      
      # Step 4: Arrow validation
      echo "🏹 Step 4: Arrow format validation..."
      python3 -c "
      import pandas as pd
      import sys
      
      try:
          arrow_df = pd.read_feather('$OUTPUT_DIR/um_${SYMBOL}_rangebar_${DATE//-/}_${DATE//-/}_0.800pct_v1.arrow')
          csv_df = pd.read_csv('$OUTPUT_DIR/um_${SYMBOL}_rangebar_${DATE//-/}_${DATE//-/}_0.800pct.csv')
          
          assert arrow_df.shape == csv_df.shape, f'Shape mismatch: {arrow_df.shape} vs {csv_df.shape}'
          print(f'✅ Arrow coherent: {len(arrow_df)} bars validated')
      except Exception as e:
          print(f'❌ Arrow validation failed: {e}')
          sys.exit(1)
      "
      
      # Step 5: Parquet validation  
      echo "📦 Step 5: Parquet format validation..."
      python3 -c "
      import pandas as pd
      import os, sys
      
      try:
          parquet_df = pd.read_parquet('$OUTPUT_DIR/um_${SYMBOL}_rangebar_${DATE//-/}_${DATE//-/}_0.800pct_v1_snappy.parquet')
          csv_df = pd.read_csv('$OUTPUT_DIR/um_${SYMBOL}_rangebar_${DATE//-/}_${DATE//-/}_0.800pct.csv')
          
          assert parquet_df.shape == csv_df.shape, f'Shape mismatch: {parquet_df.shape} vs {csv_df.shape}'
          
          csv_size = os.path.getsize('$OUTPUT_DIR/um_${SYMBOL}_rangebar_${DATE//-/}_${DATE//-/}_0.800pct.csv')
          parquet_size = os.path.getsize('$OUTPUT_DIR/um_${SYMBOL}_rangebar_${DATE//-/}_${DATE//-/}_0.800pct_v1_snappy.parquet')
          compression = (csv_size - parquet_size) / csv_size * 100
          
          print(f'✅ Parquet coherent: {len(parquet_df)} bars, {compression:.1f}% compressed')
      except Exception as e:
          print(f'❌ Parquet validation failed: {e}')
          sys.exit(1)
      "
      
      echo ""
      echo "🎉 ALL FORMAT VALIDATION PASSED"
      echo "==============================="
      echo "✅ CSV/JSON: Coherent"
      echo "✅ Arrow: Coherent" 
      echo "✅ Parquet: Coherent + Compressed"
      echo ""
      echo "Ready for production use across all formats!"

  claude_code_cli_debugging_procedures:
    format_specific_debugging:
      csv_debugging: |
        # CSV format debugging with Claude Code CLI
        head -10 output_file.csv                    # Inspect headers + first rows
        tail -5 output_file.csv                     # Check last rows
        wc -l output_file.csv                       # Count total bars
        awk -F',' '{print $1,$5,$6,$7,$8}' output_file.csv | head -5  # Key fields only
        
      json_debugging: |
        # JSON format debugging with Claude Code CLI  
        head -1 output_file.json | python -m json.tool    # Pretty-print structure
        python -c "import json; d=json.load(open('output_file.json')); print(f'Bars: {len(d)}, Fields: {list(d[0].keys())}')"
        python -c "import json; d=json.load(open('output_file.json')); [print(f'Bar {i}: {bar}') for i, bar in enumerate(d[:2])]"
        
      arrow_debugging: |
        # Arrow format debugging with Claude Code CLI
        python -c "import pandas as pd; df=pd.read_feather('output_file.arrow'); print(f'Shape: {df.shape}, Dtypes: {df.dtypes.to_dict()}')"
        python -c "import pandas as pd; df=pd.read_feather('output_file.arrow'); print(df.head())"
        python -c "import pandas as pd; df=pd.read_feather('output_file.arrow'); print(df.describe())"
        
      parquet_debugging: |
        # Parquet format debugging with Claude Code CLI
        python -c "import pandas as pd; df=pd.read_parquet('output_file.parquet'); print(f'Shape: {df.shape}, Memory: {df.memory_usage().sum()/1024**2:.1f}MB')"
        python -c "import pyarrow.parquet as pq; f=pq.ParquetFile('output_file.parquet'); print(f'Metadata: {f.metadata}')"
        ls -lh *.parquet *.csv  # Compare file sizes

  regression_testing_matrix:
    test_scenarios:
      single_day_small:
        params: "BTCUSDT 2025-08-01 2025-08-01 0.008"
        expected_bars: "~10-15"
        purpose: "Quick validation"
        
      single_day_large:
        params: "BTCUSDT 2025-08-01 2025-08-01 0.001"  
        expected_bars: "~1000+"
        purpose: "Volume stress test"
        
      multi_day_medium:
        params: "BTCUSDT 2025-08-01 2025-08-05 0.008"
        expected_bars: "~50-100"
        purpose: "Time series continuity"
        
      different_symbols:
        params: ["ETHUSDT 2025-08-01 2025-08-01 0.008", "SOLUSDT 2025-08-01 2025-08-01 0.008"]
        purpose: "Multi-asset validation"

  coherence_verification_checklist:
    data_integrity:
      - "✅ Bar counts identical across all formats"
      - "✅ OHLCV values match to 8 decimal places"
      - "✅ Timestamps preserved with millisecond precision"
      - "✅ Volume aggregation consistent"
      - "✅ Bar sequence ordering maintained"
      
    format_specific:
      csv:
        - "✅ Headers present and correctly named"
        - "✅ No trailing commas or malformed rows"
        - "✅ Decimal precision preserved"
        
      json:
        - "✅ Valid JSON structure (no syntax errors)"
        - "✅ All numeric fields properly typed"
        - "✅ No scientific notation in inappropriate fields"
        
      arrow:
        - "✅ Schema matches specification exactly"  
        - "✅ Decimal128 precision for price/volume fields"
        - "✅ Metadata preserved in file headers"
        
      parquet:
        - "✅ Compression achieved (20-80% size reduction)"
        - "✅ Snappy compression algorithm used"  
        - "✅ Metadata preserved and queryable"
        
    performance_validation:
      - "✅ Parquet loads >5x faster than CSV in pandas"
      - "✅ Arrow zero-copy loading verified"
      - "✅ Memory usage optimized for large datasets"

# Future Extensions
future_extensions:
  streaming_support:
    description: "Real-time Arrow streaming"
    timeline: "Post v3.0.0"
    
  delta_lake:
    description: "Delta Lake table format support"
    timeline: "Post v3.0.0"
    
  multi_timeframe:
    description: "Multiple range thresholds in single file"
    timeline: "Post v3.0.0"

# Current Project Status - UPDATED 2025-09-11 (Post-Validation)
current_status:
  phase: "Phase 2 Complete - Algorithm + Performance Validation"
  rust_implementation: ✅ Complete - Pure Rust range bar construction working  
  data_fetching: ✅ Complete - Direct data.binance.vision integration
  algorithm_validation: ✅ Complete - Breach consistency validation implemented
  performance_validation: ✅ Complete - 116M trades/sec (11.6x better than target)
  correctness_validation: ✅ Complete - Real data processing (1.38M trades validated)
  multi_asset_support: ✅ Complete - BTCUSDT, ETHUSDT, SOLUSDT, ADAUSDT tested
  security_updates: ✅ Complete - All dependency vulnerabilities fixed
  
  # Missing Core Functionality (High Priority)
  arrow_parquet_integration: ❌ Not Started - No binary format support
  multi_market_support: ❌ Not Started - UM futures only (no CM/SPOT)
  market_type_cli: ❌ Not Started - Hardcoded to UM futures
  comprehensive_format_validation: ❌ Partial - Basic validation only

# CRITICAL VALIDATION FRAMEWORK - EMPIRICAL DISCOVERY
validation_framework:
  breach_consistency_validation:
    description: "Cross-validation method for algorithm correctness"
    empirical_discovery: "More rigorous than individual breach detection"
    rule: "If high >= upper_threshold OR low <= lower_threshold, then close must also breach same threshold"
    rationale: "Breaching trade that triggers bar closure becomes the close price"
    implementation: "(high_breach → close_breach) AND (low_breach → close_breach)"
    workflow_validation: "Validates trade processing, threshold detection, breach inclusion, bar closing"
    
  step_by_step_verification_methodology:
    description: "Systematic testing approach for production confidence"
    empirical_insight: "Iterative testing prevents failure cascades"
    phases:
      - "Environment foundation (toolchain, dependencies)"
      - "Core validation (unit tests, algorithm correctness)" 
      - "Build verification (debug, release)"
      - "Performance validation (speed + correctness)"
      - "Real data processing (actual Binance trades)"
      - "Cross-validation (breach consistency checks)"
    
  performance_plus_correctness_validation:
    description: "Dual validation requirement"
    empirical_learning: "Speed metrics alone insufficient - need correctness proof"
    requirements:
      - "Performance targets: 1M ticks < 100ms (achieved: 8.6ms)"
      - "Throughput targets: >100M trades/sec (achieved: 116M trades/sec)"
      - "Correctness proof: Breach consistency across all bars"
      - "Real data validation: Actual Binance market data processing"

  # Statistical Analysis Framework Implementation
  statistical_framework: ✅ Complete - Comprehensive SOTA statistical analysis integrated
  statistical_crates: ✅ Complete - statrs, quantiles, polars, nalgebra, peroxide integrated
  metadata_generation: ✅ Complete - 91KB comprehensive statistics module implemented
  market_microstructure: ✅ Complete - Advanced financial metrics and analysis
  format_validation: ✅ Complete - Cross-format validation methodology documented
  parallel_computation: ✅ Complete - Rayon integration for statistical performance
  
  # Data Integrity & Workspace Organization
  data_integrity_verification: ✅ Complete - SHA256 verification for Binance downloads implemented
  workspace_organization: ✅ Complete - Scripts organized (scripts/analysis/, scripts/testing/)
  dependency_validation: ✅ Complete - Cargo.toml dependencies validated and Arrow/Parquet ready
  filesystem_cleanup: ✅ Complete - All .DS_Store and backup files removed
  background_process_cleanup: ✅ Complete - Resource-consuming processes resolved

# SOTA Statistical Analysis Framework - PHASE 1.5 IMPLEMENTATION
statistical_analysis_framework:
  overview: |
    Comprehensive statistical analysis framework implemented with 200+ metrics for 
    market microstructure analysis. Leverages SOTA Rust crates for high-performance
    financial time series analysis and generates extensive JSON metadata.

  implemented_crates:
    core_statistics:
      statrs: "0.17 - Core statistical distributions and functions"
      quantiles: "0.7 - Streaming quantile estimation (CKMS, T-Digest)"
      uses: ["Distribution analysis", "Percentile computation", "Outlier detection"]
      
    data_processing:
      polars: "0.35 - High-performance DataFrame operations with lazy evaluation"
      features: ["lazy", "temporal", "strings", "parquet", "csv"]
      uses: ["Time series aggregation", "Window functions", "Statistical computations"]
      
    mathematical_computation:
      nalgebra: "0.33 - Linear algebra backend for complex calculations"
      peroxide: "0.37 with O3 features - Scientific computing with BLAS optimizations"
      uses: ["Matrix operations", "Covariance analysis", "Principal component analysis"]
      
    performance_optimization:
      rayon: "1.11 - Parallel computation for statistical processing"
      hashbrown: "0.14 - Fast HashMap implementation for statistical caches"
      smallvec: "1.13 - Stack-allocated vectors for small statistical collections"
      ahash: "0.8 - High-performance hashing for statistical indices"

  comprehensive_metadata_structure:
    schema_version: "1.0.0"
    dataset_info:
      fields: ["symbol", "market_type", "date_range", "source_exchange", "data_format"]
      validation: "Schema-validated with comprehensive data lineage"
      
    algorithm_configuration:
      fields: ["threshold_bps", "algorithm_version", "processing_mode", "precision_mode"]
      documentation: "Complete algorithm parameters and execution context"
      
    core_statistics:
      price_statistics: "OHLC statistics, price distributions, volatility metrics"
      volume_statistics: "Volume distributions, flow analysis, aggregation metrics"
      time_statistics: "Duration analysis, time-based patterns, session metrics"
      
    market_microstructure_analysis:
      spread_estimation: "Bid-ask spread analysis from trade data"
      liquidity_metrics: "Volume-based liquidity indicators and market depth"
      noise_analysis: "Price noise characterization and signal extraction"
      impact_analysis: "Trade impact on price movements"
      
    advanced_financial_metrics:
      volatility_models: "GARCH-style volatility estimation and forecasting"
      correlation_analysis: "Cross-asset correlation and co-movement analysis"
      risk_metrics: "VaR, CVaR, maximum drawdown, tail risk measures"
      performance_attribution: "Factor-based performance decomposition"
      
    quality_assurance_metrics:
      data_completeness: "Missing data analysis and gap detection"
      outlier_detection: "Statistical outlier identification and flagging"
      consistency_checks: "Cross-validation and sanity checks"
      processing_diagnostics: "Performance timing and resource usage"

  statistical_engine_architecture:
    parallel_processing:
      framework: "Rayon-based parallel computation"
      thread_safety: "Lock-free statistical computations where possible"
      memory_efficiency: "Streaming algorithms for large datasets"
      
    streaming_algorithms:
      quantile_estimation: "CKMS and T-Digest for memory-efficient percentiles"
      rolling_statistics: "Online algorithms for moving averages and variance"
      incremental_updates: "Efficient re-computation for streaming data"
      
    statistical_configuration:
      precision_settings: "Configurable numerical precision for statistical calculations"
      computation_modes: ["fast_approximate", "high_precision", "memory_optimized"]
      parallel_thresholds: "Automatic parallel/serial mode selection based on data size"

  json_metadata_enhancement:
    comprehensive_export: |
      JSON files now contain extensive statistical metadata alongside range bar data:
      - Core OHLCV range bars (primary data)
      - Complete statistical analysis (200+ metrics)
      - Market microstructure insights  
      - Data quality assessments
      - Algorithm execution diagnostics
      
    metadata_schema:
      data_section: "Core range bar OHLCV data"
      statistics_section: "Comprehensive statistical analysis"
      quality_section: "Data quality and validation metrics"
      performance_section: "Processing performance and diagnostics"
      format_section: "Cross-format compatibility information"
      
    statistical_profiling:
      raw_data_profile: "Comprehensive profiling of raw aggTrades input"
      range_bar_profile: "Statistical characterization of output range bars"  
      transformation_analysis: "Statistical analysis of raw→range bar transformation"
      comparative_metrics: "Performance vs traditional time-based bars"

  feature_integration:
    cargo_features: |
      [features]
      default = ["statistics", "data-integrity"] 
      statistics = ["dep:statrs", "dep:quantiles", "dep:polars", "dep:nalgebra", "dep:peroxide"]
      data-integrity = ["dep:sha2", "dep:crc32fast", "dep:md5"] 
      performance-optimized = ["dep:hashbrown", "dep:smallvec", "dep:ahash"]
      
    conditional_compilation: "Statistics module only compiled with 'statistics' feature"
    backward_compatibility: "Non-statistical builds remain lightweight and fast"
    
  implementation_status:
    statistics_module: "✅ Complete - 91KB comprehensive implementation"
    cargo_integration: "✅ Complete - All SOTA crates integrated"
    library_exports: "✅ Complete - Public API exposed via lib.rs" 
    binary_integration: "🔄 In Progress - Export binary using statistical engine"
    json_enhancement: "🔄 In Progress - Enhanced JSON with comprehensive metadata"
    
  performance_characteristics:
    computational_overhead: "~10-15% additional processing time for full statistical analysis"
    memory_usage: "Streaming algorithms minimize memory footprint"
    parallel_scaling: "Linear scaling with CPU cores for statistical computations"
    precision_vs_speed: "Configurable trade-offs between precision and performance"

  validation_framework:
    statistical_accuracy: "Cross-validation against reference implementations"
    numerical_stability: "Tested with extreme market conditions and edge cases"
    performance_benchmarks: "Performance validation across different dataset sizes"
    memory_safety: "Rust's ownership system ensures memory-safe statistical computations"
  
  next_phase: "Phase 3 - Arrow/Parquet Integration (Core Missing Functionality)"
  immediate_priorities:
    priority_1_arrow_parquet: "Add binary format support - biggest gap vs YML plan"
    priority_2_market_type_cli: "Add market_type parameter (um_futures, cm_futures, spot)"
    priority_3_comprehensive_validation: "Complete format validation framework from YML"
    
  immediate_tasks:
    - "Add apache-arrow and parquet crate dependencies to Cargo.toml"
    - "Implement Arrow schema with decimal128 precision and metadata"
    - "Add Parquet writer with Snappy compression"
    - "Add market_type CLI parameter (currently hardcoded to UM)"
    - "Update file naming with market type prefixes"
    - "Implement comprehensive format validation suite"

# Planning Status - EMPIRICAL UPDATE
planning_status: "Updated based on empirical experience - phases reordered"
completion_status: "Phase 1-2 complete (validation), Phase 3-6 not started"
priority: "HIGH - Arrow/Parquet integration is biggest gap"
estimated_effort: "1-2 weeks for Arrow/Parquet integration + market type support"
last_updated: "2025-09-11T20:30:00Z"

# Success Criteria - EMPIRICAL VALIDATION
success_criteria:
  algorithm_correctness: ✅ "Breach consistency validation implemented and verified"
  performance_targets: ✅ "116M trades/sec (11.6x better than 100ms target)"
  real_data_validation: ✅ "1.38M Binance trades processed and verified"
  security_foundation: ✅ "All vulnerabilities fixed, dependency tree clean"
  
  # Missing Core Functionality
  binary_format_support: ❌ "Arrow/Parquet integration not implemented"
  multi_market_support: ❌ "Only UM futures, no CM/SPOT support"
  comprehensive_testing: ❌ "Basic validation only, full framework missing"
  python_ecosystem: ❌ "No discovery tools or seamless integration"

# EMPIRICAL INSIGHTS FOR FUTURE DEVELOPMENT
empirical_insights:
  validation_first_principle: "Algorithm validation must precede format expansion"
  dual_validation_requirement: "Performance AND correctness validation both essential"
  iterative_testing_methodology: "Step-by-step verification prevents cascading failures"
  breach_consistency_discovery: "Cross-validation more rigorous than individual tests"
  security_foundation_principle: "Dependency security required before production features"