//! Step-by-Step Trace Validation - Find Over-Generation Root Cause
//!
//! Detailed tracing of GPU vs CPU bar generation to identify exactly
//! where the 25% over-generation occurs (15 vs 12 bars).

use rangebar::{
    range_bars::RangeBarProcessor,
    types::AggTrade,
    fixed_point::FixedPoint,
};

#[cfg(feature = "gpu")]
use rangebar::gpu::{
    multi_symbol::MultiSymbolGpuProcessor,
    metal_backend::detect_gpu_device,
};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ðŸ” **STEP-BY-STEP TRACE VALIDATION**");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("Goal: Identify exact source of 25% over-generation (15 vs 12 bars)\\n");

    #[cfg(not(feature = "gpu"))]
    {
        println!("âŒ GPU feature not enabled. Run with: cargo run --example step_by_step_trace_validation --features gpu");
        return Ok(());
    }

    #[cfg(feature = "gpu")]
    {
        run_trace_validation()
    }
}

#[cfg(feature = "gpu")]
fn run_trace_validation() -> Result<(), Box<dyn std::error::Error>> {
    let threshold_bps = 8000; // 0.8% threshold

    println!("ðŸ§ª **Trace Configuration:**");
    println!("   Single symbol: BTCUSDT");
    println!("   Threshold: {}bps ({}%)", threshold_bps, threshold_bps as f32 / 10000.0);
    println!("   Strategy: Step-by-step bar creation tracing\\n");

    // Create SIMPLE deterministic scenario with KNOWN breach pattern
    let trades = create_simple_breach_scenario();
    println!("ðŸ“Š **Simple Breach Scenario Created**");
    println!("   Trades: {}", trades.len());
    for (i, trade) in trades.iter().enumerate() {
        println!("   Trade {}: price={:.2}, volume={:.2}, timestamp={}",
            i, trade.price.to_f64(), trade.volume.to_f64(), trade.timestamp);
    }
    println!();

    // CPU PROCESSING WITH DETAILED TRACING
    println!("ðŸ–¥ï¸  **CPU PROCESSING WITH TRACE**");
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    let cpu_bars = run_cpu_with_trace(&trades, threshold_bps)?;
    println!("   âœ… CPU completed: {} bars generated\\n", cpu_bars.len());

    // GPU PROCESSING WITH DETAILED TRACING
    println!("ðŸš€ **GPU PROCESSING WITH TRACE**");
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    let gpu_bars = run_gpu_with_trace(&trades, threshold_bps)?;
    println!("   âœ… GPU completed: {} bars generated\\n", gpu_bars.len());

    // DETAILED COMPARISON ANALYSIS
    println!("ðŸ” **DETAILED BAR-BY-BAR COMPARISON**");
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    println!("Bar Count Analysis:");
    println!("   CPU: {} bars", cpu_bars.len());
    println!("   GPU: {} bars", gpu_bars.len());
    println!("   Difference: {} bars", (gpu_bars.len() as i32 - cpu_bars.len() as i32).abs());

    if cpu_bars.len() != gpu_bars.len() {
        println!("\\nâŒ **OVER-GENERATION CONFIRMED**");
        if gpu_bars.len() > cpu_bars.len() {
            println!("   GPU over-generated by {} bars", gpu_bars.len() - cpu_bars.len());
            println!("   Analysis: GPU likely closing bars too early or creating extra bars");
        } else {
            println!("   GPU under-generated by {} bars", cpu_bars.len() - gpu_bars.len());
            println!("   Analysis: GPU likely missing breach detections");
        }

        // Compare existing bars side-by-side
        println!("\\nðŸ“Š **Bar-by-Bar Comparison:**");
        let max_bars = cpu_bars.len().max(gpu_bars.len());

        for i in 0..max_bars {
            println!("   Bar {}:", i);

            if let Some(cpu_bar) = cpu_bars.get(i) {
                println!("     CPU: O={:.2} H={:.2} L={:.2} C={:.2} V={:.2} Trades={}",
                    cpu_bar.open, cpu_bar.high, cpu_bar.low, cpu_bar.close,
                    cpu_bar.volume, cpu_bar.trade_count);
            } else {
                println!("     CPU: âŒ MISSING");
            }

            if let Some(gpu_bar) = gpu_bars.get(i) {
                println!("     GPU: O={:.2} H={:.2} L={:.2} C={:.2} V={:.2} Trades={}",
                    gpu_bar.open, gpu_bar.high, gpu_bar.low, gpu_bar.close,
                    gpu_bar.volume, gpu_bar.trade_count);
            } else {
                println!("     GPU: âŒ MISSING");
            }

            // Highlight differences
            if let (Some(cpu_bar), Some(gpu_bar)) = (cpu_bars.get(i), gpu_bars.get(i)) {
                if cpu_bar.open != gpu_bar.open || cpu_bar.close != gpu_bar.close {
                    println!("     âš ï¸  OHLC MISMATCH");
                }
                if cpu_bar.trade_count != gpu_bar.trade_count {
                    println!("     âš ï¸  TRADE COUNT MISMATCH");
                }
            }
            println!();
        }
    } else {
        println!("âœ… **BAR COUNT MATCH**: Both generated {} bars", cpu_bars.len());

        // Still check OHLC integrity
        let mut ohlc_matches = true;
        for i in 0..cpu_bars.len() {
            let cpu_bar = &cpu_bars[i];
            let gpu_bar = &gpu_bars[i];

            if cpu_bar.open != gpu_bar.open || cpu_bar.high != gpu_bar.high ||
               cpu_bar.low != gpu_bar.low || cpu_bar.close != gpu_bar.close {
                ohlc_matches = false;
                println!("   Bar {}: OHLC mismatch", i);
                println!("     CPU: O={:.2} H={:.2} L={:.2} C={:.2}",
                    cpu_bar.open, cpu_bar.high, cpu_bar.low, cpu_bar.close);
                println!("     GPU: O={:.2} H={:.2} L={:.2} C={:.2}",
                    gpu_bar.open, gpu_bar.high, gpu_bar.low, gpu_bar.close);
            }
        }

        if ohlc_matches {
            println!("ðŸŽ¯ **PERFECT ALIGNMENT**: Identical bar count AND OHLC values!");
        } else {
            println!("âš ï¸  Bar counts match but OHLC values differ");
        }
    }

    // ROOT CAUSE ANALYSIS
    println!("\\nðŸŽ¯ **ROOT CAUSE ANALYSIS**");
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    if gpu_bars.len() > cpu_bars.len() {
        println!("ðŸ” **Over-generation Hypotheses:**");
        println!("   1. GPU finalizing extra bars during processing");
        println!("   2. Threshold recalculation creating false breaches");
        println!("   3. Single-tick bars being created inappropriately");
        println!("   4. Breach detection timing differs from CPU");

        // Check for single-tick bars (O=H=L=C)
        let single_tick_bars = gpu_bars.iter()
            .filter(|bar| bar.open == bar.high && bar.high == bar.low && bar.low == bar.close)
            .count();

        if single_tick_bars > 0 {
            println!("   âŒ Found {} single-tick bars (O=H=L=C) - ALGORITHM BUG!", single_tick_bars);
        }
    }

    Ok(())
}

#[cfg(feature = "gpu")]
fn run_cpu_with_trace(trades: &[AggTrade], threshold_bps: u32) -> Result<Vec<rangebar::types::RangeBar>, Box<dyn std::error::Error>> {
    println!("Starting CPU processing with trace...");

    let mut processor = RangeBarProcessor::new(threshold_bps);
    let bars = processor.process_trades(trades)?;

    println!("CPU Trace Results:");
    println!("   Processed {} trades â†’ {} bars", trades.len(), bars.len());

    for (i, bar) in bars.iter().enumerate() {
        println!("   CPU Bar {}: O={:.2} H={:.2} L={:.2} C={:.2} (trades={})",
            i, bar.open, bar.high, bar.low, bar.close, bar.trade_count);
    }

    Ok(bars)
}

#[cfg(feature = "gpu")]
fn run_gpu_with_trace(trades: &[AggTrade], threshold_bps: u32) -> Result<Vec<rangebar::types::RangeBar>, Box<dyn std::error::Error>> {
    println!("Starting GPU processing with trace...");

    let device = detect_gpu_device().ok_or("GPU not available")?;
    let gpu_processor = MultiSymbolGpuProcessor::new(device, threshold_bps, Some(trades.len()));

    let symbol_trades = vec![("BTCUSDT", trades)];
    let gpu_results = gpu_processor.process_tier1_parallel(&symbol_trades)?;

    let bars = if let Some((_, bars)) = gpu_results.get(0) {
        bars.clone()
    } else {
        Vec::new()
    };

    println!("GPU Trace Results:");
    println!("   Processed {} trades â†’ {} bars", trades.len(), bars.len());

    for (i, bar) in bars.iter().enumerate() {
        println!("   GPU Bar {}: O={:.2} H={:.2} L={:.2} C={:.2} (trades={})",
            i, bar.open, bar.high, bar.low, bar.close, bar.trade_count);
    }

    Ok(bars)
}

/// Create simple scenario with CLEAR breach pattern for tracing
fn create_simple_breach_scenario() -> Vec<AggTrade> {
    let mut trades = Vec::new();
    let base_timestamp = 1640995200000i64;
    let mut current_price = 50000.0;

    // Create 10 trades with predictable breach pattern
    for i in 0..10 {
        let price_change = if i == 0 {
            0.0 // First trade opens bar
        } else if i == 5 {
            0.012 // Clear breach at trade 5 (+1.2% vs 0.8% threshold)
        } else if i == 8 {
            -0.015 // Clear breach at trade 8 (-1.5% vs 0.8% threshold)
        } else {
            (i as f64 * 0.1) % 1.0 * 0.002 - 0.001 // Small movements Â±0.1%
        };

        current_price *= 1.0 + price_change;

        trades.push(AggTrade {
            agg_trade_id: (i as i64) + 1,
            price: FixedPoint::from_str(&format!("{:.2}", current_price)).unwrap(),
            volume: FixedPoint::from_str("1.0").unwrap(),
            first_trade_id: (i as i64 + 1) * 10,
            last_trade_id: (i as i64 + 1) * 10,
            timestamp: base_timestamp + (i as i64) * 1000,
            is_buyer_maker: i % 2 == 0,
        });
    }

    trades
}

#[cfg(not(feature = "gpu"))]
fn run_trace_validation() -> Result<(), Box<dyn std::error::Error>> {
    println!("GPU feature not available");
    Ok(())
}